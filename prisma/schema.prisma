// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String  @id @default(uuid())
  email     String  @unique
  password  String?
  name      String?
  createdAt DateTime @default(now())
  transactions Transaction[]
  categories Category[]
  accounts   Account[]

  sentFriendRequests     Friendship[]   @relation("SentRequests")
  receivedFriendRequests Friendship[]   @relation("ReceivedRequests")
  expenseSplits          ExpenseSplit[]
  groupMemberships       GroupMember[]

  // --- NEW FIELDS FOR EXPENSES ---
  expenseParticipants    ExpenseParticipant[]

  // --- Opposite relations for settlements and group balances ---
  expensesPaid           Expense[]        @relation("ExpensePayer")
  settlementsFrom        Settlement[]     @relation("SettlementFrom")
  settlementsTo          Settlement[]     @relation("SettlementTo")
  groupBalances          GroupBalance[]
}

model Account {
  id                 String    @id @default(cuid())
  userId             String
  provider            String
  providerAccountId   String
  refreshToken        String?
  accessToken         String?
  expiresAt          Int?
  tokenType          String?
  scope               String?
  idToken             String?
  sessionState        String?

  user   User    @relation(fields: [userId], references: [id])
  @@unique([provider, providerAccountId])
}

model Transaction {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  type        String   // "income" | "expense"
  categoryId  String
  category    Category @relation(fields: [categoryId], references: [id])
  amount      Decimal
  description String?
  date        DateTime @default(now())
  receipt     String? // URL of the uploaded receipt

  // --- NEW FIELD FOR SPLITTING ---
  // Link to a shared expense if this transaction was split
  sharedExpense SharedExpense?
}

model Category {
  id     String  @id @default(uuid())
  userId String
  name   String
  type   String   // "income" or "expense"
  user   User    @relation(fields: [userId], references: [id])
  transactions Transaction[]
  budget Int?
}

// --- NEW MODELS FOR FRIENDS & BILL SPLITTING ---

model Friendship {
  id           String   @id @default(uuid())
  requesterId  String
  receiverId   String
  status       String   // "PENDING", "ACCEPTED", "BLOCKED"
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  requester User @relation("SentRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  receiver  User @relation("ReceivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([requesterId, receiverId]) // Prevents duplicate friend requests
}

// Represents a transaction that is shared among friends
model SharedExpense {
  id            String   @id @default(uuid())
  transactionId String   @unique // Links to the original transaction record
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  description   String
  createdAt     DateTime @default(now())
  
  // The individual splits that make up this shared expense
  splits        ExpenseSplit[]
}

// Details how a single shared expense is split among users
model ExpenseSplit {
  id              String   @id @default(uuid())
  sharedExpenseId String
  userId          String
  amountPaid      Decimal
  amountOwed      Decimal
  netBalance      Decimal
  settled         Boolean  @default(false)

  sharedExpense   SharedExpense @relation(fields: [sharedExpenseId], references: [id], onDelete: Cascade)
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// --- GROUPS & MEMBERSHIP ---
model Group {
  id        String        @id @default(uuid())
  name      String
  createdAt DateTime      @default(now())
  members   GroupMember[]
  expenses  Expense[]
  settlements Settlement[]
  groupBalances GroupBalance[]
  // Add more fields as needed (e.g., description)
}

model GroupMember {
  id      String   @id @default(uuid())
  groupId String
  userId  String
  role    String   // "admin", "member"
  group   Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  joinedAt DateTime @default(now())
  @@unique([groupId, userId])
}

// --- EXPENSES & PARTICIPANTS ---
model Expense {
  id          String   @id @default(uuid())
  groupId     String?
  amount      Decimal
  description String?
  date        DateTime @default(now())
  splitType   String   // "equal", "custom", etc.

  payerId     String
  group       Group?   @relation(fields: [groupId], references: [id])
  payer       User     @relation("ExpensePayer", fields: [payerId], references: [id])
  participants ExpenseParticipant[]
}

model ExpenseParticipant {
  id         String   @id @default(uuid())
  expenseId  String
  userId     String
  paid       Decimal
  share      Decimal
  netBalance Decimal

  expense    Expense  @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([expenseId, userId])
}

// --- SETTLEMENTS & GROUP BALANCES ---
model Settlement {
  id          String   @id @default(uuid())
  fromUserId  String
  toUserId    String
  groupId     String?
  amount      Decimal
  status      String   @default("PENDING") // "PENDING", "PAID"
  createdAt   DateTime @default(now())

  fromUser    User     @relation("SettlementFrom", fields: [fromUserId], references: [id])
  toUser      User     @relation("SettlementTo", fields: [toUserId], references: [id])
  group       Group?   @relation(fields: [groupId], references: [id])
}

model GroupBalance {
  id        String   @id @default(uuid())
  groupId   String
  userId    String
  balance   Decimal

  group     Group    @relation(fields: [groupId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
  @@unique([groupId, userId])
}


